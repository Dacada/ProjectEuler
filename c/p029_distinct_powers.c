#include "euler.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*
 * Consider all integer combinations of a**b for 2 <= a <= 5 and 2 <=
 * b <= 5:
 *
 * 2**2=4, 2**3=8, 2**4=16, 2**5=32
 * 3**2=9, 3**3=27, 3**4=81, 3**5=243
 * 4**2=16, 4**3=64, 4**4=256, 4**5=1024
 * 5**2=25, 5**3=125, 5**4=625, 5**5=3125
 *
 * If they are then placed in numerical order, with any repeats
 * removed, we get the following sequence of 15 distinct terms:
 *
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 *
 * How many distinct terms are in the sequence generated by a**b for 2
 * <= a <= 100 and 2 <= b <= 100?
 *
 *
 * Numbers get big fast. 100**100 is a pretty big number.  But if we
 * work with doubles it doesn't really matter if we have overflow or
 * loss of precission, as long as there's no aliasing. We asume there
 * won't be.
 */

static int run(void) {
  NUM_TYPE result = 0;
  double terms[100*100+1];
  
  for (int a=2; a<=100; a++) {
    for (int b=2; b<=100; b++) {
      double c = pow((double)a, (double)b);

      // Could be improved by using a btree
      bool found = false;
      for (int i=0; i<result; i++) {
	if (c == terms[i]) {
	  found = true;
	  break;
	}
      }

      if (!found) {
	terms[result++] = c;
      }
    }
  }

  printf("%"NUM_TYPE_PRINTF"\n", result);
  return 0;
}

int main(void) {
  int exit_code = time_wrapper(run);
  if (exit_code != 0) {
    perror("error");
  }

  return EXIT_SUCCESS;
}
